<!-- livebook:{"persist_outputs":true} -->

# Advent 2023 - Day 3

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Section

```elixir
input = Kino.Input.textarea("Please paste your input file")
```

```elixir
input =
  input
  |> Kino.Input.read()
  |> String.split("\n")
  |> Enum.map(fn row ->
    row
    |> String.codepoints()
    |> Enum.map(fn cell ->
      case Integer.parse(cell) do
        {x, _} -> x
        :error -> cell
      end
    end)
    |> Enum.map(fn cell ->
      case cell do
        "." -> nil
        x -> x
      end
    end)
  end)
```

<!-- livebook:{"output":true} -->

```
[
  [4, 6, 7, nil, nil, 1, 1, 4, nil, nil],
  [nil, nil, nil, "*", nil, nil, nil, nil, nil, nil],
  [nil, nil, 3, 5, nil, nil, 6, 3, 3, nil],
  [nil, nil, nil, nil, nil, nil, "#", nil, nil, nil],
  [6, 1, 7, "*", nil, nil, nil, nil, nil, nil],
  [nil, nil, nil, nil, nil, "+", nil, 5, 8, nil],
  [nil, nil, 5, 9, 2, nil, nil, nil, nil, nil],
  [nil, nil, nil, nil, nil, nil, 7, 5, 5, nil],
  [nil, nil, nil, "$", nil, "*", nil, nil, nil, nil],
  [nil, 6, 6, 4, nil, 5, 9, 8, nil, nil]
]
```

## Part 1

```elixir
defmodule Schematic do
  def surronding(grid, {x, y}) do
    for xp <- -1..1 do
      for yp <- -1..1 do
        x = xp + x
        y = yp + y

        if (xp == 0 && yp == 0) || x < 0 || y < 0 do
          nil
        else
          row = Enum.at(grid, y)

          if is_nil(row) do
            nil
          else
            Enum.at(row, x)
          end
        end
      end
    end
  end

  def mark_seen(grid) do
    grid
    |> Enum.with_index()
    |> Enum.map(fn {row, y} ->
      row
      |> Enum.with_index()
      |> Enum.map(fn {cell, x} ->
        near_symbol =
          surronding(grid, {x, y})
          |> List.flatten()
          |> Enum.filter(&is_bitstring(&1))
          |> Enum.any?()

        {cell, near_symbol}
      end)
    end)
  end

  def smush_into_part_ids(row) do
    smush_into_part_ids(row, [], [])
    |> Enum.map(&Enum.reverse(&1))
  end

  def smush_into_part_ids([{num, symbol} | rest], cur_num, so_far) when is_number(num) do
    smush_into_part_ids(rest, [{num, symbol} | cur_num], so_far)
  end

  def smush_into_part_ids([_not_num | rest], cur_num, so_far) when length(cur_num) == 0 do
    smush_into_part_ids(rest, cur_num, so_far)
  end

  def smush_into_part_ids([_not_num | rest], cur_num, so_far) do
    smush_into_part_ids(rest, [], [cur_num | so_far])
  end

  def smush_into_part_ids([], cur_num, so_far) when length(cur_num) == 0 do
    so_far
  end

  def smush_into_part_ids([], cur_num, so_far) do
    [cur_num | so_far]
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Schematic, <<70, 79, 82, 49, 0, 0, 17, ...>>, {:smush_into_part_ids, 3}}
```

```elixir
Schematic.mark_seen(input)
|> Enum.map(&Schematic.smush_into_part_ids(&1))
|> Enum.concat()
|> Enum.filter(fn part_id ->
  Enum.any?(part_id, fn {_, symbol} -> symbol end)
end)
|> Enum.map(fn part_id ->
  part_id
  |> Enum.map(&elem(&1, 0))
  |> Enum.join("")
  |> Integer.parse()
  |> elem(0)
end)
|> Enum.sum()
```

<!-- livebook:{"output":true} -->

```
4361
```

## Part 2

```elixir

```

<!-- livebook:{"output":true} -->

```
nil
```
